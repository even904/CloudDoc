---
author: [Even]
date: [2025年06月17日]
update: [2025年06月17日]
title: [【嵌入式】第一篇：C_C++混合编译实践记录]
tags: [嵌入式,C,C++,STM32]
---

## 1. 工具链
关于使用什么编译器和开发环境，在此不过多赘述。笔者历来倾向于开源工具链，以及作为忠实的vscode用户，选择自己搭建开发环境。跨平台、开源、定制性、可控，这些优点足够让人飞蛾扑火般尝试和繁琐的配置过程作斗争。当然，新工具和新的集成开发环境也偶尔让人羡慕，这里就看个人选择了。

列表记录主要信息如下：

|目标硬件|代码生成器|构建器|生成器|编译器|编辑器|硬件调试器|调试驱动层|调试器|LSP|格式化|
|---|---|---|---|---|---|---|---|---|---|---|
|STM32H723VG|STM32CubeMX|CMake|Unix Makefiles|arm-none-eabi-gcc 14.2.1|vscode|st-link v2|openocd|gdb|clangd|.clang-format|

这些工具链和环境配置早已有人整理过，不再多言。

## 2. C/C++混合编译

混合编译之前，先问下自己，**为什么需要做混合编译？能从中获得什么样的好处？**

不要因为听起来高大上而盲目地去做，要根据实际需求来决定。显而易见，大部分C程序运行效率都高于同功能的C++实现。但当我们遇到抽象层不够抽象，代码复用性不高的情况时，C++的面向对象、封装、继承和多态特性就显得尤为重要。

然而，不是所有C++的标准库在嵌入式系统中都能使用，了解什么能用什么不能用也尤其重要。
基本上，只要有C++编译器支持，就可以使用相应的已实现的标准库。这要求我们从compiler导出可用的头文件路径，而非手动寻找。这个需求已被clangd考虑在内，它提供了`--query-driver`启动参数，可以指定编译器路径，从而自动获取头文件路径。

由此我们便可以放心大胆地使用常用的C++标准库了，诸如`<vector>`、`<functional>`等可以较好地兼容嵌入式系统。

然而，一些高级特性，如`<thread>`，由于显而易见的理由，在嵌入式系统中不可用。

当你放心大胆地创建好`.cpp`、`.h`文件后，很快你将面临第一个问题。

#### 1. 如何在C++文件中调用C函数？
这看起来似乎不难。C++包含了C的大部分特性，我们使用一个简单的声明即可：
``` C
extern "C" {
    void c_function()
    {
        // C function implementation
        // ...
    }
}
```
但为什么这样是可以的？
- `extern "C"`告诉编译器，`c_function`是一个C函数，应该按照C的规则进行链接，而不是C++的规则。C++的名称修饰（name mangling）机制会为函数名添加额外的信息，以便支持函数重载等功能。而C语言没有这些特性，因此函数名不会被修改。使用`extern "C"`可以避免这种名称修饰，使得C++能够正确地调用C函数。需要注意的是，**头文件和源文件中都需要使用 `extern "C"` 来声明C函数**，以确保编译器在所有地方都能正确地处理这些函数。
更常用地，为了区分，我们会启用条件编译。
``` C
#ifdef __cplusplus
extern "C" {
#endif
    void c_function()
    {
        // C function implementation
        // ...
    }
#ifdef __cplusplus
}
#endif
```
这样我们在C和C++文件中都可以调用`c_function()`函数了。

当你费尽心思解决了上述问题后，你将马上面临第二个类似问题。

#### 2. 如何在C文件中调用C++函数？
这听起来是个很复杂的问题。按照上面的逻辑，把多的信息去掉是个简单的事情，但把没有的信息加上却是个难题。

当我们使用C++时，往往已经处在应用层上，而C代码往往在底层。此时我们通过一个wrapper头文件打包好所有需要被C++调用的C函数接口即可，这样我们可以规避C调用C++的问题，但有时候我们不得不这么做。比如当我们需要在某通信回调函数中调用C++的成员函数执行数据处理时，我们就不得不解决这个问题。

```
    // void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
    // {
    //     if(huart == &huart7)
    //     {
    //     // UWBAnchor_receive(uwb_anchor_ptr);
    //     if(HAL_UARTEx_ReceiveToIdle_DMA(&huart7, rx_byte, 1024) != HAL_OK)
    //     {
    //         Error_Handler();
    //     }
    //     HAL_UART_Transmit(&huart1, rx_byte, Size, HAL_MAX_DELAY);
    //     __HAL_DMA_DISABLE_IT(&hdma_uart7_rx,DMA_IT_HT);
    //     }
```
